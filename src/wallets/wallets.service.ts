import {
  Injectable,
  NotFoundException,
  ConflictException,
  InternalServerErrorException,
  BadRequestException,
} from '@nestjs/common';
import { CreateWalletDto } from './dto/create-wallet.dto';
import { TransferWalletDto } from './dto/transfer.dto';
import { TransactionsService } from '../transactions/transactions.service';
import { Wallet } from './entities/wallet.entity';
import { Repository } from 'typeorm/repository/Repository';
import { InjectRepository } from '@nestjs/typeorm';
import { DataSource } from 'typeorm';
import { Decimal } from 'decimal.js';
import { Response } from '../interceptors/transform.interceptor';

@Injectable()
export class WalletsService {
  constructor(
    @InjectRepository(Wallet)
    private walletsRepository: Repository<Wallet>,

    private dataSource: DataSource,
    private readonly transactionsService: TransactionsService,
  ) {}

  async createWallet(dto: CreateWalletDto) {
    const newWallet = this.walletsRepository.create({
      // id: crypto.randomUUID(),
      currency: dto.currency,
      balance: '0',
    });

    // 2. Save the object to the database
    const savedWallet = await this.walletsRepository.save(newWallet);

    // 3. Return the saved object (which now includes any defaults/autogenerated values)
    return savedWallet;
  }

  async fundWallet(walletId: string, amount: number) {
    const queryRunner = this.dataSource.createQueryRunner(); // Create QueryRunner

    await queryRunner.connect();
    await queryRunner.startTransaction(); // Start the transaction block

    try {
      // 1. Fetch the wallet within the transaction's context (crucial for locking/consistency)
      const wallet = await queryRunner.manager.findOneOrFail(Wallet, {
        where: { id: walletId },
        // If concurrency is a concern, consider adding a pessimistic lock here
      });

      // 2. Record the transaction (Assuming transactionsService uses the same queryRunner or is adapted)
      // NOTE: If transactionsService uses its own repo, you might need to refactor it to accept queryRunner
      await this.transactionsService.createCredit({
        walletId,
        amount,
      });

      const currentBalance = new Decimal(wallet.balance);
      const fundingAmount = new Decimal(amount);

      // 3. Update the balance in memory
      console.log('Current Balance:', wallet, 'Funding Amount:', amount, typeof wallet.balance, typeof amount);
      wallet.balance = currentBalance.plus(fundingAmount).toFixed(2);

      // 4. PERSISTENCE: Save the updated balance using the query runner
      await queryRunner.manager.save(wallet);

      // 5. Commit if both steps succeeded
      await queryRunner.commitTransaction();

      return wallet; // Return the updated wallet
    } catch (err) {
      // 6. Rollback if any step failed
      await queryRunner.rollbackTransaction();
      console.error('Funding failed, rolling back:', err);
      throw new InternalServerErrorException(
        'Failed to fund wallet due to a transaction error.',
      );
    } finally {
      // 7. Release the query runner regardless of success or failure
      await queryRunner.release();
    }
  }

  async transfer(dto: TransferWalletDto): Promise<Response> {
    const { fromWalletId, toWalletId, amount } = dto;

    // 1. Initial Validation
    if (fromWalletId === toWalletId) {
      throw new ConflictException('Cannot transfer money to the same wallet.');
    }

    if (amount <= 0) {
      throw new BadRequestException('Transfer amount must be positive.');
    }

    const queryRunner = this.dataSource.createQueryRunner();
    await queryRunner.connect();
    await queryRunner.startTransaction(); 

    try {

      const sender = await queryRunner.manager.findOneOrFail(Wallet, {
        where: { id: fromWalletId },
        
      });

      const receiver = await queryRunner.manager.findOneOrFail(Wallet, {
        where: { id: toWalletId },
      });

      // 3. Business Logic Validation (re-check balance after fetching)
      if (new Decimal(sender.balance).lessThan(amount)) {
        throw new ConflictException(
          'Insufficient balance in the sender wallet.',
        );
      }

      // 4. Record the Debit Transaction
      // NOTE: The transaction service should be adapted to use the passed queryRunner/manager
      await this.transactionsService.createDebit(
        {
          walletId: sender.id,
          amount: amount,
        },
        queryRunner,
      );

      await this.transactionsService.createCredit(
        {
          walletId: receiver.id,
          amount: amount,
        },
        queryRunner,
      );

      // Update balances
      sender.balance = new Decimal(sender.balance).plus(amount).toFixed(2);
      receiver.balance = new Decimal(receiver.balance).plus(amount).toFixed(2);

      await queryRunner.manager.save(sender);
      await queryRunner.manager.save(receiver);

      await queryRunner.commitTransaction();

      return { message: 'Transfer processed successfully' };
    } catch (error) {
      // rollback if any error occurs
      await queryRunner.rollbackTransaction();

      if (
        error instanceof ConflictException ||
        error instanceof BadRequestException
      ) {
        throw error;
      }

      console.log('Transfer failed, rolling back:', error);
      throw new InternalServerErrorException(
        'Transfer failed due to a system error.',
      );
    } finally {
      await queryRunner.release();
    }
  }

  async getWalletDetails(walletId: string) {
    const wallet = await this.findWallet(walletId);
    const transactions = await this.transactionsService.getByWallet(walletId);

    return { wallet, transactions };
  }

  private async findWallet(walletId: string) {
    // Use findOneOrFail to automatically throw a NotFoundException if not found
    const wallet = await this.walletsRepository
      .findOneOrFail({
        where: { id: walletId },
      })
      .catch(() => {
        throw new NotFoundException('Wallet not found');
      });

    return wallet;
  }

  async getAllWallets(): Promise<Response> {
    let wallets = await this.walletsRepository.find();
    return { message: 'Wallets retrieved successfully', data:wallets };
  }
}
